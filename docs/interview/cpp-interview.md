---
icon: note
date: 2022-01-11
category:
  - 面经汇总
tag:
  - CPP语言基础
---

# CPP面经汇总

## CPP语言基础
### 1、简述C++语言的特点

+ C++在C语言的基础上引入了面向对象的机制，同时兼容C语言；

+ C++面向对象包括了封装、继承、多态三大特性；

+ C++语言生成的代码质量高，运行效率高；

+ C++增加了const常量、引用、强制类型转换、智能指针、Lambda匿名函数、右值引用等新特性，功能语法更为灵活复杂；

+ C++可复用性高，引入了模板概念，在此基础上实现了STL标准模板库，大大方便了开发等等。

### 2、C语言和C++的区别

+ C++语言很好的兼容了C语言，同时又引入了很多新特性，如引用、智能指针等；

+ C++是面向对象的编程语言，而C语言是面向过程的编程语言；

+ C语言有一些不安全的语言特性，比如指针使用的潜在危险、强制类型转换的不确定性、内存泄漏等。而C++增加了不少新特性来改善安全性，例如引用、智能指针等。

+ C++有模板、函数重载等新概念，C语言中是没有的；

+ C语言和C++的内存管理不太一样，C中使用malloc和free，C++中使用new和delete。

### 3、C++中struct和class的区别

+ struct一般用于描述一个数据结构集合，而class是对一个对象的数据和功能的封装；

+ struct中默认的访问控制权限是public，而class是private；

+ struct中默认的继承是公有继承，class默认是私有继承；

+ **class可以用于定义模板参数，struct不能。**

### 4、C语言中的struct和C++的区别

+ C语言的struct不能有成员函数，C++中可以有；

+ C语言中struct不能有静态成员，C++中可以有；

+ C语言中struct默认访问权限的public，且不能更改；C++中默认是public，但可以更改；

+ C语言中struct不可以继承，C++中可以从类或者其他结构体继承；

+ **C语言中struct不能直接初始化数据成员，C++中可以**；

+ **C语言中使用struct必须带上struct关键字或者取别名，C++中可以省略**。

|          |          C           |             C++             |
| :------: | :------------------: | :-------------------------: |
| 成员函数 |        不能有        |            可以             |
| 静态成员 |        不能有        |            可以             |
| 访问控制 | 默认public，不能修改 |  public/private/protected   |
| 继承关系 |       不能继承       | 可以从class或其他struct继承 |
|  初始化  |   不可以直接初始化   |       可以直接初始化        |

### 5、C++中include头文件的顺序以及双引号和尖括号的区别

+ 尖括号<>的头文件表示是系统文件，头文件的查找路径是：编译器设置的头文件路径->系统变量；

+ 双引号“”的头文件表示是自定义文件，头文件的查找路径是：当前头文件目录->编译器设置的头文件路径->系统变量。

### 6、C++中extern的作用是什么

C++中，extern关键字的作用是导入C，表达形式是extern "C"。有些时候需要在C++中使用到一部分C语言，为了能让编译器将这部分代码按照C语言的编译方式进行编译，需要使用extern "C"。

### 7、C++编译和C语言编译时有什么区别

由于C++语言支持函数重载，可能会出现多个同名函数，为了能够正确区分，**编译时会将函数的参数类型一同编译**，而C语言没有函数重载，编译时不会带上参数类型，一般只包含函数名。

### 8、C++程序编译的过程

C++程序编译总共有四个过程：预编译、编译、汇编和链接。

**预编译（预处理）：**做一些预处理工作，例如将所有的#define删除，展开宏定义、处理所有的预处理命令、过滤掉注释等等；

**编译：**做一些词法分析、语法分析、语义分析以及代码优化工作，生成汇编代码；

**汇编：**将汇编代码转换成机器可识别的指令，生成目标文件；

**链接：**将不同源文件的产生的目标文件进行链接，生成可执行程序。

### 9、动态链接和静态链接的区别

+ 静态链接指的是在生成可执行文件时就将不同源文件产生的目标文件链接起来，形成一个可执行文件，程序执行时不再依赖静态链接库。

+ 动态链接指的是**将程序拆分成相对独立的模块**，生成动态链接库，可执行文件中需要用的动态库中函数的地方用标记代替，程序运行时需要用到的时候再去动态链接库中查找链接。

+ 静态链接的缺点是生成的可执行文件体积大，并且会出现同一个目标文件的代码有多个副本的情况；而且只要有一个静态库修改，整个可执行程序必须重新编译生成，速度比较慢；优点是程序运行速度快，运行时不需要再去查找链接。

+ 动态链接的优缺点则相反，因为运行时再去链接目标文件，所以可执行文件体积较小，多个地方需要用到同一个目标文件时也不会产生多个副本，而是共享同一个动态库文件；而且改变动态库，不会对可执行程序产生影响；缺点是运行速度相对要慢一些。

### 10、动态绑定和静态绑定的区别（不要和上面一条混淆）

+ **静态类型：**对象在声明时采用的类型，在编译期就已经确定；
+ **动态类型：**通常指一个指针或引用所指的对象类型，需要在运行时决定；

+ **静态绑定：**将对象相关的属性或函数绑定为它的静态类型，就是声明时的类型，在编译期就确定了；

+ **动态绑定：**将对象的相关属性或函数绑定为它的动态类型，对象的具体属性或函数需要在运行时确定，通常使用虚函数实现动态绑定。

### 11、C++中static的用法

static的意思是静态的，可以用来修饰变量、函数和类成员。

+ static修饰变量可以是静态全局变量，也可以是静态局部变量，它们都存放在静态存储区。区别在于静态全局变量的作用域是它所在的源文件，而静态局部变量作用域只在对应的函数或代码块中。整个源程序执行过程中它们始终存在，只不过超出作用域后就不能访问，整个程序结束后才回收释放。

+ static修饰函数时表示该函数是静态函数，静态函数只能在当前文件中使用，不能被其他文件所调用，也不会和其他文件中的同名函数冲突。

+ static修饰类成员变量时表示该变量是属于类的，属于该类的所有实例共用该变量；修饰成员函数时也一样，可以直接通过类名来调用该函数。

### 12、static变量的初始化时间

在C语言中，**编译阶段分配好内存之后就会进行初始化**，所以在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束时，static变量所在的全局内存会被全部回收。

而在C++语言中，**在执行相关代码时才会进行初始化**，主要是由于C++引入对象之后，要进行初始化必须执行相应的构造函数和析构函数，在构造函数或者析构函数中经常会进行某些程序中需要的特定操作，并非简单的分配内存。所以C++标准规定，对于全局或者类的静态成员变量，是在main()函数执行前由运行时调用相应的代码进行初始化的。而对于局部静态变量，是在函数执行至此初始化语句时才开始执行的初始化。也可以说是在第一次使用到时才初始化。

**初始化的静态变量在数据段.data上分配内存，未初始化或者初始化为0的静态变量在.bss段分配内存。**

### 13、数组和指针的区别

数组用于存储多个**类型相同**的数据集合，数组名是第一个元素的地址；指针相当于一个变量，它存放的是其他变量的地址。因此它们的区别有：

+ 同类型的指针可以相互赋值，而数组不行，必须一个一个的拷贝元素赋值；

+ 存储方式不同，数组在内存中是连续存放的，可以根据下标进行访问；指针比较灵活，它本身就是一个变量，有自己的地址，同时它指向的内存地址跟它指向的变量相关。指针指向数组的首地址时，由于数组是连续内存的，所以通过改变指针的指向遍历数组。

+ sizeof的区别：sizeof(数组)求的是数组的容量，而sizeof(指针)求的是指针的大小，32位系统是4字节，64位是8字节。

### 14、什么是函数指针和指针函数，有什么应用场景

函数指针就是指向函数的指针变量，每个函数都有一个入口，该入口地址就是函数指针指向的地址。函数指针一般用于回调（callback）。

指针函数指的是一个函数返回类型是一个指针。

### 15、什么是野指针，该如何避免

野指针指的是指针指向的位置是随机的，不可知的，无法预料后果。产生野指针的原因一般是因为释放指针指向的内存后没有及时将指针置空。

避免产生野指针的方法：

+ 初始化指针时置NULL；

+ 申请内存后判断是否为空；

+ 内存释放后指针置NULL；

+ 使用智能指针；

+ 养成良好的编程习惯。

### 16、inline内联函数和宏函数的区别

+ 宏函数严格来说不是函数，只是使用起来像函数，在预处理阶段用复制宏代码的方式替代函数调用，省去了函数压栈退栈的过程，提高了效率；

+ 内联函数本质是函数，一般将函数体代码较为简单的函数声明成内联函数，编译器在编译阶段会将每一处调用内联函数的地方直接将内联函数展开，这样可以省去函数调用的开销。

+ 宏定义是简单的字符串替换，没有类型安全检查，而内联函数本质是函数，有类型安全检查。

### 17、运算符++i和i++的区别

两者都是自增运算符，单独作为运算符使用时并无不同，但是参与运算上就有区别：

+ ++i是先加1再参与运算，而i++是先参与运算再加1；

+ ++i的效率比i++要高一些；

+ i++不能作为左值，而++i可以作为左值；

+ 两者都不是原子操作。

原因在于，a = i++是先用一个临时对象保存i，再将i自增，返回的是临时对象，所以不能用作左值，同时因为创建临时对象，效率会低一些；而++i是直接以引用的方式返回的，不需要创建临时变量，效率自然会高一些，也能够用作左值。

### 18、new和malloc的区别

+ 申请内存所在位置不同，new从自由存储区上为对象动态分配内存空间，而malloc从堆上动态分配内存空间。（注意自由存储区和堆的区别，自由存储区是基于C++  new操作符的一个抽象概念，凡是new申请的内存都叫做自由存储区，而堆是操作系统的概念，自由存储区可以是堆，也可以是其他区域，具体要看operator new的实现细节，C++默认的operator new是使用malloc申请内存的，所以应该是在堆上，而operator  new是可以重载的，可以指定别的内存申请方式。）

+ 返回类型的安全性，new内存分配成功后，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，所以new是类型安全的；而malloc内存分配成功返回的是void *，需要强制类型转换成我们需要的类型。

+ 内存分配失败时的返回值不同，new内存分配失败会抛出异常，malloc分配失败返回NULL。

+ new申请内存时不需要手动指定内存大小，编译器会根据类型信息自行计算，而malloc申请时需要手动指定内存大小。
+ 使用new和delete时会调用对象的构造和析构函数，而使用malloc和free不会调用。

+ new操作符有new[]和delete[]专门处理数组类型。

+ new和delete的实现基于malloc和free，但是malloc不能调用new。

+ new和delete可以被重载，但是malloc和free不能被重载。

+ 使用malloc分配内存后，如果使用中发现内存分配不足，可以使用realloc函数进行内存重新分配实现扩容。realloc先判断当前指针指向的内存是否有足够的连续内存空间，如果有原地扩大内存，如果没有，申请一块更大的新内存，将原来的数据拷贝进新内存空间，再释放掉旧的内存空间，返回新内存空间的地址。new没有相应的措施实现扩容。

+ 在operator new抛出异常以反应一个为获得满足的需求之前，他会先调用一个用户指定的错误处理函数，这就是new_hander。new_hander是一个指针类型，指向一个没有参数返回值的函数，即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_hander，set_new_hander的参数为new_hander指针，指向了operator new无法分配足够内存时该调用的函数。其返回值也是这个指针，指向set_new_hander被调用前正在执行的那个new_hander。

  对于malloc，客户并不能够去编程决定内存分配不足时应该干什么事，只能看着malloc返回NULL再采取措施。

总结如下表：

| 特征                       | new/delete                           | malloc/free              |
| -------------------------- | ------------------------------------ | ------------------------ |
| 分配内存的位置             | 自由存储区                           | 堆                       |
| 内存分配成功返回值         | 完成类型指针                         | void *                   |
| 内存分配失败返回值         | 默认抛出异常                         | 返回NULL                 |
| 分配内存大小               | 由编译器根据类型决定                 | 必须显式指定字节数       |
| 处理数组                   | 有处理数组版本new[]/delete[]         | 需要用户计算数组大小     |
| 内存扩充                   | 无法直观处理                         | 使用realloc扩充          |
| 是否能够相互调用           | 可以调用malloc                       | 不可以调用new            |
| 分配内存不足时操作         | 客户能够指定处理函数或重新制定分配器 | 无法通过用户代码进行处理 |
| 函数重载                   | 允许重载                             | 不允许重载               |
| 是否调用析构函数和构造函数 | 调用                                 | 不调用                   |

### 19、new和malloc的底层实现

+ malloc：当开辟的空间小于128k时，调用brk()函数；当开辟的空间大于128k时，调用mmap()，malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块连接起来，每个空闲块记录了一个未分配的、连续的内存地址。

+ new：调用operator new函数申请空间，operator new调用的是malloc来申请空间，然后在申请的空间上执行构造函数完成对象构造，最后返回对象。

### 20、const和define的区别

+ define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小；

+ define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值；

+ define不会进行类型安全检查，而const会进行类型安全检查，安全性更高；

+ const可以定义函数而define不可以。

### 21、指针函数和函数指针的区别

指针函数本质是一个函数，返回的是某一类型的指针；函数指针本质是指针，指向的是一个函数。

### 22、C++中const关键字的作用

+ const修饰类的成员变量时，表示常量不能被修改。

+ const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数。

### 23、常量指针、指针常量以及常指针常量  

+ 常量指针：`int const* p = 10;` 常量指针不可以通过指针修改指向的变量的值，但是可以更改指针的指向。

+ 指针常量：`char * const p = "ABCD";`指针常量可以通过指针修改指向变量的值，但是不能修改指针的指向。

+ 常指针常量：`const int * const p = 10;`既不能修改指针的指向，也不能通过指针修改指向变量的值。

### 24、inline内联函数和普通函数的区别

+ 内联函数避免了函数调用的开销；普通函数有函数调用的开销。

+ 普通函数在调用是需要寻址，即找到函数的入口地址；内联函数不需要，直接将函数展开。

+ 内联函数限制比较多，要求函数体代码简单，不能包含复杂的结构控制语句，循环语句等。

+ 内联函数的定义必须出现在内联函数第一次被调用前。

### 25、C++的四种强制类型转换

+ static_cast：用于各种隐式转换，比如各种基本数据类型的转换，int转char等；派生类指针转父类指针。static_cast转换时没有类型安全检查，从派生类指针转换为基类指针时没有问题，但是从基类指针转换为派生类指针时会有安全问题。static_cast不能转换const、volatile属性。

+ dynamic_cast：用于动态类型转换，基类指针转换为派生类指针，或者派生类指针转换为基类指针。dynamic_cast有类型安全检查，当不能转换时会返回NULL。

+ const_cast：用于去除const属性，使其可以被修改；也能用于volatile属性转换。

+ reinterpret_cast：强制类型转换，几乎可以用于任何转换，比如任意指针之间、引用之间转换等，但是比较危险。

### 26、声明和定义的区别

+ 声明是告诉编译器变量或函数的类型和名字，不会为变量分配空间；

+ 定义就是对这个变量和函数进行内存分配和初始化，需要分配空间，同一个变量可以被声明多次，但是只能被定义一次。

### 27、typedef和define区别

+ define是预处理命令，在预处理是执行简单字符串的替换，不做正确性的检查；

+ typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名。

### 28、C++有几种传参的方式

+ 值传递：形参是实参的拷贝，函数内部修改形参不会影响实参；

+ 引用传参：引用实际上是变量的别名，引用传参可以简单理解成传递进去的就是实参，因此函数内部对形参的修改就是对实参的修改，省去了生成副本的时间和空间开销，效率比较高；引用传参要求引用的变量必须初始化。

+ 指针传参：指针传参的本质是值传递，传递的是指针指向对象的地址，也需要进行地址拷贝，内部可以通过解引用的方式修改外部实参；指针传参可以不初始化，在函数内部可以初始化外部实参。

### 29、友元函数和友元类

友元提供了不同类的成员函数之间进行数据共享的机制。通过友元，另一个类中的成员函数可以访问当前类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

使用友元类时注意：

(1) 友元关系不能被继承。

(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。

(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。

### 30、volatile关键字

volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化，（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。  

### 31、引用和指针的区别

+ 引用必须定义时就初始化，且之后不可变，指针可以不初始化，可改变。

+ `int &const r = a;`是错误的，因为引用本身就不能改变指向，添加const多此一举。

+ 指针是一个实体，而引用仅仅是一个别名。

+ 引用不能为空(NULL)，指针可以为空(NULL)。

+ 指针可以有多级，但是引用只能一级。即指针可以`int **`，引用不能`int &&`。

+ 指针的`++, --`代表指向上一个或者下一个数据，而引用的`++,--`代表当前数据本身的加减。

+ `sizeof引用`得到的是引用所指向的对象的大小，而`sizeof指针`得到的是指针本身的大小。

+ 当指针和引用作为函数参数时，指针传递参数会生成临时变量，引用传递参数不会生成临时变量。（指针传递本质是值传递复制实参的地址到函数的栈中，然后形参对该地址取值操作。而引用的形参实际上只是给实参取了一个别名，可通过形参直接控制实参）。

+ **引用是类型安全的，而指针不是，引用比指针多了类型检查。**

+ 指针和引用作为函数参数时，指针需要检查是否为空，引用不需要。

### 32、C++的三种访问权限

+ **public：**可以被该类的函数、子类的函数、友元函数访问，也可以由该类的对象访问。

+ **private：**可以被该类中的函数、友元函数访问，不可以由子类函数、该类的对象访问。

+ **protected：**可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问。

### 33、静态成员函数和普通成员函数的区别

可以说静态成员函数的出现就是为了处理静态成员变量的。静态成员函数与普通成员函数的根本区别在于：

+ 普通成员函数有this指针，可以访问类中任意成员；而静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

+ 与普通成员函数相比，静态成员函数是属于类的，不管有没有创建对象，主函数都可以调用静态成员函数。

### 34、new operator和operator new的区别

我们常使用new来创建一个新的对象，这里用的new其实就是new operator，这是C++内建好的，无法重载，实际上调用new创建新对象执行了三个过程：

+ 调用 operator new分配内存；

+ 调用对应的构造函数在分配的内存空间上生成对象；

+ 返回相应的对象。

所以可以知道，operator new其实是在调用new operator时用来分配内存的，C++的operator new分配和释放内存是基于malloc和free实现的，但其实你可以自己定义一套内存分配方案，也就意味之operator new是可以重载的。

### 35、什么是placement new

简单翻译过来叫做放置 new 操作符，所谓放置肯定要先有地方才能放，所以其实也叫定位new操作符，这个操作符的作用是**在指定的内存上生成对象**。有一些场景需要反复地构造析构对象，这样会导致多次申请和释放内存，导致效率很低，placement new可以保持在同一块内存中构造析构对象，省去大量的内存申请释放操作。

### 36、C++空类有几个成员函数

对于空类，编译器不会生成任何成员函数，只会生成1个字节的占位符。

有时可能会认为编译器会为空类生成默认构造函数等，事实上是不会的，编译器只会在需要的时候生成默认成员函数，C++98会生成构造、析构、拷贝构造、拷贝赋值四个默认函数，C++11在此基础上增加了移动拷贝和移动赋值两个默认函数，且这些函数都是inline和public的。

### 37、C++11有几种构造函数

默认构造函数，也叫无参构造函数；初始化构造函数；拷贝构造函数；移动构造函数。

+ 默认构造函数：默认构造函数没有参数，是编译器自己生成的，可以不用显示声明，但是如果有了有参构造函数后，编译器就不再生成默认构造函数，需要使用时只能显示声明。

+ 初始化构造函数：自定义的有参数的构造函数，会屏蔽编译器自动生成的默认构造函数。

+ 拷贝构造函数也是编译器自动生成的，通过拷贝另一个对象的方式来构造对象，但是默认是浅拷贝，如果需要用到深拷贝，需要自行定义。

+ 移动构造函数：C++11加入的新特性之一，传入的是该类对象的一个右值引用，通过内存转移的方式实现新对象的构造，省区了拷贝过程中的开销。

### 38、mutable关键字的作用

在C++中被const关键字修饰的类成员函数是无法修改类的成员变量的，但是有时候**对于某些成员变量我们又需要在const函数中对其进行修改**，这个时候可以使用mutable关键字，**被mutable关键字修饰的成员变量，在任何时候都是允许修改的，即使是在const函数中**。

### 39、函数加const关键字算不算重载

**关键字const修饰的是参数还是函数？**

如果修饰的是参数，**值传递的时候不构成重载**，因为此时加不加关键字const对函数内部功能没有什么影响；**如果是指针或引用传参就是重载**，因为加了const后函数内部就不能对参数做修改，改变了函数的功能。

类的成员函数加上const也会构成重载，因为此时加了const和不加const的函数功能不一样。

### 40、std::move函数的作用

**作用是强制将左值转化为右值**，右值一般可以理解成临时对象，通过临时对象去生成新对象，如果涉及到深拷贝的时候，需要重新开辟内存，花销比较大，但是临时对象用完就不用了，还要释放内存，所以C++11加入了移动构造函数，可以直接将一个右值引用的对象内存直接移动给新对象，省去了内存的申请和释放操作。但是很多时候外部对象定义成了左值，为了也能够使用移动构造函数，就可以用move函数强制将左值对象转化为右值。

使用move函数后，原对象的状态是不确定的，一般写程序会需要将原对象里面用到的指针指向空，程序结束后原对象仍然会析构，但是move过后一般就不能在使用了，否则会出错。

### 41、拷贝构造函数和赋值函数的区别

拷贝构造函数是使用一个类对象去初始化另一个类对象，而赋值函数是将一个类对象赋值给另一个类对象，简单点说就是赋值运算符的重载。两者的区别在于：

+ 使用赋值函数的前提是两个类对象都必须已经存在，而使用拷贝构造函数的时候，等待构造的对象还不存在，构造结束才存在。

+ 一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象。

+ 实现上有一些区别，在使用赋值函数的时候，如果被赋值的类对象已经存在内存分配，需要先释放掉，同时还要检查两个对象是否相同，同一个对象就直接返回。

### 42、多继承情况下，C++类对象的初始化顺序

+ 创建派生类对象时，基类的构造函数优先被调用，也优先于派生类中的其他成员类对象；

+ 如果类中有其它类对象，成员类对象的构造函数优先被调用；

+ 如果继承了多个基类，按照继承顺序依次调用构造函数；

+ 类中有多个成员类对象，按照声明的顺序依次构造；

总之：父类构造函数 -> 成员类对象构造函数 -> 自身构造函数。析构的顺序正好相反。

### 43、虚函数和纯虚函数的区别

+ 有纯虚函数的类被称为抽象类，不能用于实例化；而只有虚函数的类不是抽象类，是可以用于实例化的；

+ 基类的虚函数是可以直接使用的，也可以被子类重写后以多态的形式调用；但是纯虚函数在基类中只有声明没有定义，只有在子类中实现后才能使用。

### 44、拷贝构造函数的参数传递方式

**拷贝构造函数的参数传递必须是引用传递**，如果是值传递的话，相当于实参到形参会调用拷贝构造函数，从而造成无穷递归调用拷贝构造函数。指针传递也不行，因为指针传递的本质也是值传递。

### 45、C++中的模板

泛型编程是C++中一个非常重要的概念，也就是在编写代码的时候不依赖于具体的数据类型，模板是泛型编程的基础，也是实现多态的一种方法。相对于继承和虚函数实现的多态，模板实现的多态是静态多态，在编译期就能确定对象类型。C++中模板会编译两次，第一次发生在正常的编译期，主要是检查有无语法错误；第二次发生在模板的调用时，生成具体的模板函数。

### 46、模板编程能否将头文件和源文件分开，为什么

C++是采用分离编译的，函数的声明一般写在头文件中，定义写在源文件中，不同的源文件编译会得到不同的目标文件，一个目标文件如果需要用到另一个目标文件的函数，在编译汇编阶段会采用函数标记的方式进行处理，然后在链接阶段才去查找对应的函数实现。

但是对于模板函数来说，只有在使用的时候才会进行实例化，分配内存，分阶段编译意味着在编译成不同目标文件的时候，模板函数所在的目标文件中没有对模板函数进行实例化，也就不会分配内存，所以在链接阶段是找不到对应的模板函数的，就会出现未定义的错误。解决的办法一个是提前对模板函数实例化，这显然太过于麻烦，另一个是将模板函数的声明和定义写在**同一个头文件中**。

### 47、union和struct的区别

区别主要体现在多成员情况下，struct每个成员都有自己的内存空间，而union是所有成员共用一个存储空间，内存大小由最大的数据成员决定，后面初始化的成员会将前面的成员信息覆盖掉。

### 48、nullptr和NULL的区别

NULL在C语言中是一个宏，表示空指针，C语言中可以发生隐式转换，变成int* , char*等；但是C++是强类型的，不允许这种隐式转换的发生，于是C++重新定义了NULL宏，在C++中NULL默认表示0，又由于C++中引入了函数重载，如果继续用NULL表示空指针会出现二义性的问题，所以C++中直接引入了nullptr，在任何时候都表示空指针。

## 内存相关

### 1、堆和栈的区别

+ 堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是操作系统自动管理的内存，存放函数的参数和局部变量；

+ 堆空间因为会有频繁的内存分配和释放操作，容易产生内存碎片；

+ 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小；

+ 栈使用的是一级缓存，它们通常都是被调用时处于存储空间中，调用完立即释放；堆则是使用二级缓存，速度会慢一些。

### 2、堆和栈哪个速度快一些，为什么

栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

### 3、简述C++内存管理结构

C++中，内存一共分为5个区，由高地址到低地址分别是栈区、堆区、全局/静态存储区、常量存储区以及代码区。

<img src="https://upload-images.jianshu.io/upload_images/3444487-fccce4214dda15ec.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/895/format/webp" alt="img" style="zoom: 50%;" />

+ 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

+ 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

+ 全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。

+ 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。

+ 代码区，存放程序的二进制代码。

关于这个有很多种说法，有的会增加一个自由存储区，存放new分配得到的内存，与堆相似。

### 4、内存泄漏和检测、解决办法

动态分配内存所开辟的空间，在使用完毕后未手动释放，导致该内存一直被占据，即为内存泄漏。

造成内存泄漏的几种原因：

+ 类的构造函数和析构函数中new和delete没有配套；

+ 在释放对象数组时没有使用delete[]，使用了delete；

+ 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露；

+ 没有正确的清除嵌套的对象指针。

检测方法：

+ 主要利用工具进行检测：ccmalloc、Dmalloc、Leaky、**Valgrind**等。

+ 检测的实质就是检查new和delete或malloc和free有没有配套使用，匹配是否正确。

避免方法：

+ malloc/free要配套；

+ 使用智能指针；

+ 将基类的析构函数设为虚函数。

### 5、什么是内存溢出和内存越界

+ 内存溢出指的是程序在申请内存时，没有足够的内存空间供其使用。

+ 内存越界指的是申请了一块内存，使用的时候超出了这块内存区域。

### 6、一个程序有哪些段section

从低地址到高地址，一个程序由代码段、数据段(data)、BSS段、堆、共享区、栈等组成。

+ 代码段： 存放程序执行代码的区域，只读，代码段头部还会包含一些只读常数变量；

+ 数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域；

+ BBS段：存放程序中未初始化的全局变量和静态变量的一块区域；

+ 堆区和栈区，程序运行时使用的两个内存区；

+ 共享区：位于堆区和栈区之间。

### 7、什么是内存对齐？为什么要做内存对齐

在计算机中，内存是按字节划分的，而CPU在读取数据时，并不是一个字节一个字节的读取，实际上是按块的大小读取，块大小可以是2，4，8，16等等，称为内存访问粒度，内存对齐则是将特定的数据类型按照一定的规则摆放在内存上，具体规则是按照变量的声明顺序，依次安排内存，其偏移量为变量大小的整数倍。之所以要做内存对齐主要原因有两个：

+ 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

+ 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

### 8、结构体中内存对齐的规则

+ 第一个成员在与结构体变量偏移量为0的地址；

+ 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处；

+ 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值；

+ linux 中默认为4；

+ vs 中的默认值为8；
  结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）。

内存对齐的例子：

```c++
typedef struct {
 		int a;
  		double b;
    	short c;
   	}A;
    
 typedef struct {
  		int a;
  		short b;
     	double c;
    }B;
// sizeof(A) = 24, sizeof(B) = 16;
// 对于A来说，a占用0-3，共4字节，b是double类型，偏移需要是8的整数倍，因此占用8-15共8字节，4-7字节填充，
// c是short，偏移量需要是2的整数倍，所以占用16-17共两个字节，加起来一共是20字节，结构体总字节数需要是最
// 长类型即double的整数倍，那么需要填充为24字节。对于B来说，a占用0-3，共4字节，b占用4-5共两个字节，c占用
// 8-15共8个字节，合计为16字节，是8的整数倍，顾B占用16字节。
```

### 9、 深拷贝和浅拷贝的区别

+ 浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。

+ 而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。

+ 深拷贝可以避免重复释放和写冲突。使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。

### 10、对象复用和零拷贝

对象复用指的是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式。

零拷贝指的是在进行操作时，避免CPU从一处内存空间拷贝到另一处内存空间。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。

### 11、C++函数调用的压栈过程

普通函数的调用过程：

+ 从栈空间上分配内存空间；

+ 函数参数从右向左进行压栈；

+ 函数的返回地址进行压栈；

+ 函数的局部变量进行压栈。

其他函数，例如成员函数、虚函数的调用过程和普通函数一样，主要是在调用前查找函数地址的方式不同。

### 12、被free回收的内存会立即返回给操作系统吗

不会，new或者malloc申请内存是向内存管理器申请，内存管理器再向操作系统申请，这里面涉及到系统调用，如果频繁的申请释放，效率会很低，所以一般进程申请了内存后，释放资源后并不会立即将内存还给操作系统，而是放到一个类似于内存缓存池的地方，下次申请的时候首先会在内存缓存池中查找合适的内存，减少了大量的系统调用，提高速度，当然也可以强制归还内存。

### 13、为什么C++没有垃圾回收机制

+ 首先，实现一个垃圾回收器会带来额外的空间和时间开销，需要开辟一定的空间保存指针的引用计数和对他们进行标记mark，然后需要单独开辟一个线程在空闲的时候进行free操作。

+ 垃圾回收会使得C++不适合进行很多底层的操作。

### 14、写时拷贝是什么

写时拷贝是为了解决深拷贝的不足产生的，写时拷贝的意思就是：当读取到这块空间的时候，并不会立即开辟出一个一模一样的空间给你用，而是真正需要去写的时候再开辟出空间使用，实际上就是一个拖延版的深拷贝。

写时拷贝是通过“引用计数”实现的，在分配空间的时候多分配4个字节，用来记录有多少个指针指向这块内存空间，当有新的指针指向这块空间时，引用计数加一，当要释放这块内存空间时，引用计数减一，假装释放，只有当引用计数为0时才真正释放该空间。有了引用计数就知道当前时刻有多少指针指向该内存，当有指针想要改变这块空间的值时，为了不影响其他指针，需要为这个指针开辟新的内存空间，此时新的空间引用计数加一，旧空间的引用计数减一。

## 面向对象相关

### 1、面向对象和面向过程的区别

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

### 2、面向对象的三大特征是什么

面向对象的三大特性是：封装，继承和多态。

+ 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；

+ 继承使得子类可以复用父类的成员和方法，实现了代码重用；

+ 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。

### 3、重载、隐藏、重写（覆盖）三者的区别（重要）

+ **重载：**指同一可访问区内被声明的几个具有不同参数列表（参数类型、个数、顺序不同）的同名函数，根据参数列表确定调用的是哪个函数，重载不关心函数的返回类型。 

+ **隐藏：**指派生类的函数屏蔽了与其同名的基类函数，只要同名，不管参数列表是否相同，基类函数都会被屏蔽。如果派生类中有与基类中同名的函数，参数列表不同，基类函数被隐藏；参数列表相同，基类函数没有`virtual`关键字，则基类函数被隐藏。

+ **重写（覆盖）：**是指派生类中存在重新定义基类的虚函数。其函数名、参数列表、返回值类型都必须同基类中被重写的函数一致。只有函数体不同，派生类调用时会调用派生类重写的函数，不会调用基类中的函数。基类中被重写的函数必须是虚函数。

### 4、C++函数重载是如何识别不同重载函数的

C++底层有重命名机制，使用`name mangling`（倾轧）技术，在编译的时候根据函数的参数和参数类型给函数进行唯一命名，这样就能根据参数类型知道调用的是哪个函数。

### 5、构造函数和析构函数可以被重载吗

构造函数可以被重载，因为构造函数可以有多种，且参数可以不同。

析构函数不能被重载，因为析构函数有且只有一个，且不能带参数。

### 6、向上转型和向下转型

**子类转换为父类：**向上转型，使用dynamic_cast，相对比较安全，不会有数据丢失；

**父类转换为子类：**向下转型，可以使用强制类型转换，这种转换是不安全的，会导致数据丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

### 7、什么是多态机制

面向对象的三大特征：封装、继承和多态。

多态就是说同一个名字的函数可以有多种不同的功能，分为编译时的多态和运行时的多态。**编译时的多态就是函数重载，包括运算符重载**，编译时根据实参确定调用哪个函数。**运行时的多态和虚函数、继承相关**。

### 8、多态的实现原理

利用虚函数表，先构建一个基类，然后在基类的构造函数中会建立虚函数表，也就是一个存储虚函数地址的数组，基类内存地址的前四个字节保存指向虚函数表的指针，当多个子类继承父类之后，可以通过父类指针调用不同子类的函数。

虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在.rdata只读数据段中。

### 9、inline函数可以是虚函数吗

内联函数可以是虚函数，但是当使用多态调用的时候会屏蔽内联属性，原因是内联函数是静态绑定，在编译期就完成代码展开，但是多态函数是在运行期间才决定调用哪一个函数的。具体内联不内联由编译器决定。

### 10、static静态成员函数可以是虚函数吗

静态函数不可以是虚函数。调用虚函数的过程首先是通过对象的this指针找到对应的虚表指针，通过虚表指针找到虚函数表，再在虚函数表中找到对应的虚函数。但是静态成员函数是属于类的，它不属于类的任何一个对象和实例，属于类的共有函数，不能通过this指针来访问。

### 11、构造函数可以是虚函数吗

构造函数不可以是虚函数。

一方面**因为虚函数存在的唯一目的就是为了多态**，而子类并不继承父类的构造函数，构造函数是创建对象时自己主动调用的，不可能被继承，所以没有使构造函数变成虚函数的必要。另一方面，原理上也不能这样做，虚函数地址存储在虚函数表中，创建对象时在对象内存空间上初始化一个虚函数表指针指向虚函数表，假设构造函数是虚函数，就必须通过虚函数表指针找到虚函数表，进而找到虚函数，但是此时对象还没有实例化，也就不存在虚函数表指针，更不可能找到虚函数表，因此构造函数不能是虚函数。

### 12、析构函数可以是虚函数吗

可以，也应该这么做。因为如果父类的析构函数不是虚函数，当用父类指针指向子类对象时，销毁对象时优先调用的是父类的析构函数，而不会调用子类的析构函数，这样子类对象的内存无法释放，导致内存泄露。如果父类析构函数是虚函数，那么调用析构函数时候会优先调用子类的析构函数，然后再调用父类的析构函数，能够避免出现内存泄漏。

### 13、如果析构函数不是虚函数，一定会造成内存泄漏吗

不一定。如果仅仅只是父类指针指向父类对象，析构函数不是虚函数也能正常调用父类的析构函数。如果是父类的指针指向子类对象，若析构函数不是虚函数，有可能会造成内存泄漏。

### 14、构造函数中可以调用虚函数吗

可以，但是最好别这么做，因为这样会屏蔽多态特性。因为派生类对象在构造期间进入基类的构造函数，此时子类的对象还没有实例化，为了避免调用未初始化的内存，C++规定，在构造是调用父类的构造函数，而构造函数中调用到了虚函数，即使该虚函数被子类重写，也不允许发生多态行为，父类最终调用的是自己的函数，达不到想要的目的。

### 15、对象访问普通函数快还是虚函数快

如果是普通对象访问两种函数一样快，如果是指针或引用对象访问普通函数要快一些。

因为指针或引用对象访问虚函数时，是在运行时通过查找虚函数表确定调用函数的真实地址，而访问普通函数则是在编译时期就确定了调用函数的地址，所以会更快一些。

### 16、虚函数表在什么时候生成，存在哪里

虚函数表在编译时期创建生成，存放在可执行程序的只读数据段（.rdata）中。

### 17、虚函数表继承的分布情况

+ 对于单一继承来说，只继承一张虚函数表，只有一个虚函数表指针，虚函数表中先存放父类的虚函数，如果父类的虚函数有被子类重写，将对应的虚函数地址替换成子类的，属于子类的虚函数紧接着父类的虚函数依次存放在虚函数表的后面。

+ 对于多继承的情况，有几个父类含有虚函数就会继承几张虚函数表，也会有多个虚函数表指针，多张虚函数表按照继承的顺序依次存放；当子类重写了某个父类的虚函数时，将对应的虚函数表中的函数地址替换成子类的函数地址，同时属于子类的虚函依次存放在第一张虚函数表的末尾。

### 18、菱形继承的问题，虚继承的原理

菱形继承是一种特殊的继承方式，两个派生类同时继承了一个基类，同时它们又作为基类同时被一个派生类继承，形似菱形，故叫做菱形继承。

菱形继承最底层的派生类相当于继承了最顶层基类的两份数据，会出现数据冗余和二义性的问题。解决菱形继承的方式是使用虚继承，即在派生类继承基类的时候，加上virtual关键字，表明这是虚继承，这样在间接继承同一个基类的时候会只保留一份数据。

虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

### 19、什么是RAII机制

RAII翻译过来就是资源获取就是初始化，是C++语言的一种管理资源、避免资源泄漏的方法。RAII将资源的申请和释放与对象的生命周期进行绑定，在构造对象的时候分配资源，对象生命周期内资源都是有效的，在析构对象时释放资源。

### 20、C++为什么需要this指针

因为属于同一类的多个对象的成员函数存储在公共代码段，为了知道不同对象调用成员函数的时候，到底是哪一个对象调用，C++编译器给每个非静态的成员函数增加了一个隐藏的指针参数让该指针指向当前对象，也就是函数调用时的对象，在函数体中所有成员变量的操作，都是通过这个指针完成的。

## STL相关

### 1、STL的基本组成有哪些

STL分为6部分，容器、算法、迭代器、仿函数、适配器、空间配置器。

+ 容器：是一些数据结构，例如序列容器：list、vector、deque，关联容器set、multiset、map、multimap等，以模板的方法实现。

+ 算法：是用来操作容器中数据的模板函数，例如sort函数可以对vector排序。

+ 迭代器：提供访问容器中对象的方法，事实上，迭代器是一种封装成对象的指针。

+ 仿函数：仿函数又称为函数对象，其实就是重载了操作符的struct。

+ 适配器：简单说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口。

+ 空间配置器：为STL提供空间配置的系统，主要工作包含两个部分：对象的创建和销毁，内存的获取和释放。

### 2、STL的vector容器

vector是动态数组，特点是内存是连续的，并且可以实现自动扩容，当容量不够的时候，会自动申请一块新的内存空间，一般是原来内存的两倍，然后将数据依次从旧的内存空间拷贝到新的内存空间，再释放掉旧的内存空间。可以按照索引获取数据，效率比较高，**使用vector最好事先设置好容器大小，否则频繁的进行内存申请和释放操作消耗会比较大**。

### 3、vector的底层实现

vector底层基于三个迭代器实现，分别是start、finish、end_of_storage，它们分别指向已经使用的空间的头部，已经使用空间的尾部，以及可用空间的尾部。

### 4、clear函数会释放vector的内存吗

调用clear函数并不会真正的释放vector内存，它只会析构掉vector中的对象，然后重置size。

只有当vector出了作用域后，编译器才会调用vector的析构函数释放掉内存。如果需要强制释放内存，可以使用swap函数使得vector离开作用域，从而强制释放。

### 5、vector的swap函数和assign函数的区别

swap的基础功能是用来交换两个vector容器，但是常用来**去除vector的多于容量或者强制释放vector内存**。

```c++
vector<int>(myvector).swap(myvector);
// 先利用myvector拷贝构造一个临时的vector对象，这个临时对象的容量和myvector的
// 真实元素个数相同，没有多余容量，然后利用swap函数将临时对象和myvector进行元素
// 和容量交换。
myvector.swap(vector<int>{});
```

assign函数也可以用来将另一个vector的内容复制到指定vector，与swap不同的是，swap交换只是将两个vector的头指针交换，时间复杂度是常数级的，assign交换会将目标vector的所有元素清空，然后将源vector的值插入到目的vector中，assign当源vector的元素个数大于目的vector的容量时，目的vector会扩容。

### 6、vector的resize函数和reserve函数

vector中size用来表示元素的个数，所以resize是用来改变元素个数的函数，使用它时会对元素进行初始化，只有当resize后元素个数大于容量才会扩容，其余情况不会对capcacity产生影响。reserve函数仅仅只是用来改变容量，而且只有**当改变后的容量大于改变前的容量才会起作用**，不会对元素进行初始化。

### 7、push_back和emplace_back函数的区别

都是往容器添加元素的操作函数，但是底层实现上有一些区别。push_back首先是创建一个元素，然后将这个元素拷贝或者移动到容器中；而emplace_back是直接在容器尾部构造元素，省去了元素的拷贝操作，效率上会高一些。

### 8、vector为什么选择成倍扩容而不是等差扩容

成倍扩容容量是指数增加的，一般经过常数级时间复杂度扩容后能够达到需求空间，而等差扩容是线性增加的，需要经过O(n)时间复杂度才能达到需求空间。

### 9、vector为什么选择2倍或者1.5倍扩容，而不是10倍

首先需要明确，扩容肯定是因为存不下了，所以扩容的倍数大小肯定要大于1，但是如果扩容的太大，可能导致空间过渡浪费，所以权衡下来选择1.5倍或者2倍是比较好的。

### 10、STL的list容器

list底层是使用双向链表的形式实现的，每一个元素都包含两个指针，一个指向下一个元素的地址，一个指向上一个元素的地址，所以list在内存中的位置是随机的不连续的。由于它基于双向链表实现，所以在任何地方的插入和删除操作都是常数级时间复杂度的，主要缺点是不能够通过下标索引的方式直接访问元素，必须从头节点或者尾巴节点开始遍历，时间复杂度是线性的。

因此如果需要频繁的删除、插入和移动元素的情境下，使用list会比较好，如果需要快速定位访问元素，使用vector会比较好。

### 11、STL中array和vector的异同

array是C++11引入的一个顺序容器，它与vector一样内存地址是连续的，因此可以通过下标访问元素，不同之处在于，vector是可以动态扩容的，所以vector在创建时无需指定大小，而array的容量必须指定，且不能再更改，不能添加或删除元素。相对而言，vector会更加灵活，但是代价就是效率会低一些，因为扩容会带来额外的开销。还有就是swap函数区别比较大，vector的swap实际上是进行引用交换，效率比较高，而array的swap函数是进行值得交换，效率比较低。

### 12、STL中的deque

deque叫做双端队列，使用上和vector比较相似，能够高效的在尾部插入或删除元素，支持快速访问任意元素，不同之处是它还支持在头部快速插入和删除元素。

deque的底层是由一段一段连续的内存空间实现的，通过使用一个map作为主控，存储每一段连续内存空间的首地址，从而达到整体连续的效果。当deque需要扩容时，会申请一段连续的内存空间，然后将这块内存的首地址加入主控map中。当主控map用完后，重新申请一块更大的内存作为map。

### 13、STL中的forward-list

forward_list是C++11新添加的一个容器，其底层时使用单链表实现的，因此内存分布是随机的。相对于list的双向链表而言，单链表在一些操作上不那么灵活，比如不支持反向遍历，但是在存储相同数量的元素时，使用单链表内存消耗会比双链表少，空间利用率会比较高，所以如果利用单链表就能满足要求的情境下，优先使用单链表。

### 14、STL中的set、multiset、map、multimap

这几个容器都是关联容器，底层都是使用红黑树实现的，都是按照键进行排序的。

+ set：set的元素只有键，没有value，value就是键，且不允许出现重复的键值，元素是有序的，不能通过迭代器修改set的元素值，因为set的值就是键。如果允许修改键值的话，首先要删除该键，然后调整平衡，在插入新的键值，再调节平衡，严重破坏和set的结构，导致迭代器失效，所以是不允许使用迭代器修改键值的。

+ multiset和set基本上是相同的，只不过multiset允许出现重复的键值。

+ map也是使用红黑树实现的，所有元素使用键值对的方式存储，元素按照键值进行自动排序，map的键是不允许修改的，原理和set一样，但是值是可以修改的，map中键不允许重复。

+ multimap和map一样，只不过允许重复的键值存在。

### 15、红黑树的定义

红黑树是一棵非严格平衡二叉树，它通过维持几个条件来保持平衡：

+ 节点分为红色和黑色；

+ 根节点必须是黑色；

+ 叶子节点都是黑色，且都为空；

+ 红色节点的两个子节点是黑色，也即相连的节点不会同时为红色；

+ 从任意节点出发到其每个叶子节点的所有路径包含的黑色节点数相同。

由于一棵有n个节点的红黑树的高度至少是2 * long(n)，所以它的查找、插入、删除等操作的时间复杂度都是O(logn)，当插入删除操作破坏红黑树的平衡性后，需要通过变色和旋转操作来保证满足上述条件，达到重新平衡。

+ 变色：当前节点、父亲节点以及叔叔节点都是红色，将父节点和叔叔节点设为黑色，祖父节点设为红色，然后当前节点定位到祖父节点，重复上述过程。

+ 左旋：当父子是红色，叔叔是黑色，子节点是右子树，以父亲节点进行左旋。

+ 当父子节点是红色，叔叔是黑色，当前节点在左子树，优选。首先将父亲节点设为黑色，祖父节点设为红色，把祖父节点进行右旋。

### 16、为什么map要用红黑树而不是平衡二叉树AVL

AVL是高度平衡的二叉树，而红黑树是通过相对AVL来说平衡性要弱一些，它们都可以在O(log(n))的时间复杂度下完成查找、删除和插入节点，只不过红黑树由于非严格，性能会低一些。插入和删除操作会破坏平衡性，需要重新调整平衡，对于插入操作，两者最多经过两次旋转操作就能恢复平衡，但是对于删除操作，红黑树最多三次旋转就能恢复平衡，而AVL需要O(log(n))的时间复杂度。

所以红黑树实际上是一种这种的结果，实际运用中，如果搜索次数远远大于删除，选择AVL会好一些，反之如果插入删除次数比较多，选择红黑树会好一些。

### 17、map为什么使用红黑树而不是二叉搜索树

map、set底层实现了排序的功能，红黑树节点的键值是有序的。红黑树是平衡二叉树，查找、插入和删除操作可以在O(log(n))时间复杂度下完成，但是二叉搜索树不一定是平衡二叉树，当插入的值是有序的情况下，二叉搜索树会退化成一个链表，时间复杂度就会变成O(n)。

### 18、STL中的unordered_map等无序容器

unordered_map是STL中的无序关联容器，从名字就能知道它里面的元素是无序的，并且是以键值对的方式进行存储的，键不能改变，值可以改变，除了无序看上去和map功能类似，但是map底层是用红黑树实现的，unordered_map底层基于hashtable实现，这使得unordered_map的查找操作在O(1)时间复杂度下就能完成，而map则需要O(log(n))，不过hashtable占用内存会更大一些，如果元素键值出现较多的哈希冲突，也会降低unordered_map的效率。

### 19、什么是哈希冲突，有什么解决办法

哈希表的原理是通过哈希函数，将元素的键值映射为对应的哈希值，实现O(1)的查找时间复杂度，但是可能会出现多个元素的键值通过哈希函数映射成相同的哈希值，这就是哈希冲突。哈希冲突较多第一个原因应该考虑哈希函数设计是否合理，然后再采取其他一些措施解决哈希冲突，主要有以下几种方法：

+ 开放地址法，也叫做再散列法，常用的有线性探测再散列和二测探测再散列。线性探测就是在冲突的地址处，往哈希表的下一地址进行探测，直到找到一个没有使用的地址；二次探测就是在冲突地址左右跳跃式地查找可用的地址；

+ 再哈希法，就是同时构造多个不同的哈希函数，当某个哈希函数计算的地址冲突时，利用下一个哈希函数计算，直到找到不冲突的地址，这种方法的好处是不易产生聚集，但是会增加计算时间。

+ 链地址法，这种方法就是将所有哈希值相等的元素维护成一个链表，查找的时候先找到哈希地址，然后顺着链表找到对应的元素，STL中就是使用的这种方法。

+ 建立公共溢出区，建立一个溢出表，凡是发生冲突的元素都存放到溢出表中。

### 20、什么是迭代器失效，什么情况下会发生

迭代器是STL中用来访问容器元素的方法，当对容器进行某些操作后，使得迭代器不能指向正确的地址，就叫做迭代器失效。例如在vector中，删除当前迭代器指向的元素，或者插入一个元素，都会使得后面元素的位置变化，对应的迭代器也就会失效。

## C++11新特性相关

### 1、std::function

std::funtion 是一种通用的、多态的函数封装，它的实例可以对任何可以调用的实体进行存储、复制和调用，包括普通函数、Lambda表达式、函数指针以及其它函数对象。好处是实现了一套类型消除机制，可以统一处理不同的函数对象类型。

### 2、lambda表达式

lamdba表达式是C++11引入的匿名函数，对于一些使用次数很少的函数对象类，在没有lamdba表达式之前，我们也必须为其编写一个类，定义一个对象后才能使用，有了lamdba表达式后，我们只需要定义一个lambda表达式，编译器会根据表达式自动生成一个未命名类的未命名对象，且该对象包含对operator()函数的重载，对lambda表达式的调用实际上就是对该对象的调用，但是省去了我们自己定义类和对象的繁琐操作。

### 3、lambda表达式可以捕获外部变量吗

lambda表达式可以捕获外部变量，值捕获的时候，lambda在定义时候变量的值是多少就确定了，后面改变变量的值对lambda没有影响；如果是引用捕获，变量的值是调用lambda时候的值。

### 4、unique_ptr智能指针

unique_ptr是C++11新加入的智能指针，也称为独占性智能指针，它保证同一时刻只有一个智能指针指向对象。它的内部禁用了拷贝构造和赋值函数(将函数定义为=delete实现禁用)，仅仅实现了移动构造和移动赋值函数，从而实现了独占功能。

因为unique_ptr实现了移动构造和移动赋值，所以可以通过move函数实现对象所有权的转让。

### 5、移动构造函数和移动赋值函数

C++11加入了右值引用的概念，基于右值引用实现了移动构造函数和移动赋值函数。在没有移动构造和移动赋值之前，只能用拷贝构造和赋值，这两个函数都需要先对原始对象进行拷贝，再构造新对象，但是很多时候往往这个拷贝过程是略显多余的，因为拷贝创建新对象后源对象可能就不使用了。移动拷贝和移动赋值的作用就是将即将消亡的右值对象的内存空间直接转移给新对象，避免发生拷贝，从而提高性能。但是有时往往传入的是左值，为了能够调用移动构造，提供了move函数将左值转换为右值。

### 6、shared_ptr智能指针

shared_ptr是C++11新加入的智能指针，也称为共享智能指针，它允许多个指针同时指向一个对象，使用引用计数器记录多少个shared_ptr指向该对象，只有当引用计数为0时才释放对象。

### 7、make_shared和普通构造shared_ptr的区别

普通的shared_ptr会有两次内存申请，一次是申请对象的内存，一次是申请控制块的内存，这会导致一些不好的事情发生，一个是再按顺序执行过程中会出现不安全现象；第二是性能较差，因为要申请两次内存。而make_shared可以一次性申请对象和控制块的内存，一定程度上可以减小内存碎片的出现。

### 8、weak_ptr智能指针

weak_ptr可以获取shared_ptr指针的一些状态信息，比如有多少个指向相同的shared_ptr指针，shared_ptr指针指向的堆内存是否已经被释放等等，另外还可以用来防止循环引用，配合使用lock函数。

### 9、shared_ptr是线程安全的吗

shared_ptr的引用计数本身是安全无锁的，它是原子操作，但是对象的读写不是，也就是说shared_ptr这个智能指针对象本身是安全的，但是它管理的对象不是，因此多线程读取的时候可以不加锁，读写的时候必须加锁。

### 10、unique_ptr是线程安全的吗

unique_ptr不是线程安全的。

### 11、unique_ptr是如何实现禁止拷贝和赋值的

把拷贝构造函数和赋值运算符设置为delete删除即可。

 