---
icon: note
date: 2022-01-11
category:
  - 面经汇总
tag:
  - 计算机网络面试题
---

# 计算机网络
### 1、socket()网络编程的过程

服务器端：

```cpp
socket() 	// 创建socket套接字
bind() 		// 绑定服务器地址结构
listen() 	// 设置监听上限
accept() 	// 阻塞监听客户端连接
recv() 		// 读取客户端数据
write(fd) 	// 写数据
close() 	// 关闭套接字
```

客户端：

```cpp
socket() 	// 创建socket()套接字
connect() 	// 与服务器建立连接
send() 		// 写数据到socket
read() 		// 读取服务器发送的数据
close() 	// 关闭套接字
```

### 2、TCP的慢启动、拥塞控制、快速重传、快速恢复

TCP数据传输效率同时受到发送方发送能力和接收方接收能力的影响，接收方接收能力一般和网络关系不大，受系统性能的影响较大，所以讨论TCP拥塞控制和流量控制问题时，为了简化，假设只有发送方发送数据，接收方只负责回复确认，且发送窗口大小仅与网络拥塞程度决定（实际受同时网络和接收能力影响，取最小）。

TCP拥塞控制通过维护一个拥塞窗口cwnd实现，cwnd窗口大小随着网络情况动态变化，变化原则是网络没有拥塞，增大cwnd，网络出现拥塞，减小cwnd。

TCP数据传输分为以下几个阶段：

+ 慢启动阶段：cwnd设置为1个MSS，也就是一个最大报文段；当数据发送成功且顺利收到回复确认后，就将cwnd翻倍，该阶段的cwnd实际上是指数形式增长的；cwnd增加到一定阶段就不能继续指数增长，否则会造成拥塞，这个阈值叫做慢启动门限ssthresh。当cwnd到达ssthresh后就进入到了拥塞避免阶段。

+ 拥塞避免阶段：实质就是降低cwnd的增加速度，采用线性增长替代指数增长，每成功发送一次数据收到确认后cwnd加1。当遇到超时重传时认为网络发生拥塞，此时将ssthresh设置为cwnd的一半，重新将cwnd设置为1，继续执行慢启动到拥塞控制。

+ 快速重传阶段：快重传指的是当数据丢失时让发送方尽快重传，而不是等到超时才重传。接收端接收到的报文段序号如果比期望的报文段序号大，说明中间有数据丢失，就会重复发送最近一次的ACK确认，发送方连续三次接收到重复的ACK时，就会立即重传数据，而不是等到超时。

+ 快速恢复阶段：快重传发生时不一定是因为网络拥塞，因为接收端确实还能在不超时的时间内接收到多个数据包，所以这个时候不需要进入慢启动阶段，为了预防拥塞，进入快速恢复阶段，将cwnd设置为ssthresh的一般，然后进入拥塞避免阶段，cwnd线性增加。

### 3、TCP三次握手建立连接

TCP是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后要断开连接，建立连接是通过三次握手完成的，目的是保证IP地址、端口、物理链路等正确无误，为数据传输开辟可靠通道。三次握手的过程如下：

+ 服务器端创建套接字后，调用listen()函数，进入`LISTEN`状态。

+ 客户端调用connect()函数，TCP协议组建一个数据包，设置SYN标志位，将该数据包发送给服务器端，然后客户端进入`SYN-SEND`状态。

+ 服务器端收到客户端发送的请求连接的数据包，组建一个数据包，设置SYN和ACK标志位，SYN表示数据包用来建立连接，ACK用来确认收到客户端发送的数据包，将该数据包发送给客户端，服务器端进入`SYN-SEND`状态。

+ 客户端收到服务器端发送来的数据包，检查SYN和ACK标志判断是服务器端发送的确认连接数据包。组建数据包设置ACK标志位，发送给服务器端，此时客户端进入`ESTABLISTED`状态。

+ 服务器端收到客户端的ACK确认包，进入`ESTABLISTED`状态，至此客户端和服务器端成功建立连接。

### 4、TCP建立连接为什么一定是三次握手，不能两次或四次？

TCP为了实现可靠的数据传输，传输前必须先保证发送方和接受方都同时具有发送能力和接收能力，而为了确认双方的发送和接收能力，至少需要三次通信，三次握手是代价最小的连接方式。

+ 客户端向服务器端发送SYN请求，服务器端收到SYN后知道客户端的发送能力是好的，并回复ACK和发送服务器端的SYN请求；

+ 客户端收到服务器端的ACK应答和SYN请求后，知道服务器的接受能力和发送能力都是好的（只有接收到了才回复ACK）。

+ 客户端还需要发送最后一个ACK确认，让服务器端知道客户端的接收能力是好的。

### 5、TCP四次挥手断开连接

TCP建立连接后，不再传输数据时需要断开连接，释放计算机资源，断开连接通过四次挥手实现：

+ 客户端调用close()函数后，向服务器端发送FIN标志位，进入FIN_WAIT_1状态。

+ 服务器端收到FIN标志位后，知道客户端需要断开连接，发送ACK确认包，进入CLOSE_WAIT状态。

+ 客户端收到服务器端的确认包后，进入FIN_WAIT_2状态，等待服务器进行处理。

+ 服务器端完成断开准备后，向客户端发送FIN标志位，进入LAST_ACK状态。

+ 客户端收到服务器端的FIN后，向服务器端发送ACK确认包，然后进入TIME_WAIT状态。

+ 服务器端收到客户端的ACK包后，就断开连接，进入CLOSED状态。

+ 2MSL的TIME_WAIT过去后，客户端断开连接，进入CLOSED状态。

### 6、TCP为什么要有TIME_WAIT状态

+ 可靠的关闭连接。假设主动关闭连接的一端发送的最后一个ACK分段在网络中丢包或被延迟了，被动关闭的一端因收不到ACK，会重新发送FIN包。这时如果没有TIME_WAIT状态直接处于CLOSED状态，服务器端重传的FIN不会被收到客户端收到，客户端也就不会再发送最后一个ACK，导致服务器端一直处于LAST_ACK状态，不能正常关闭。极端情况下，ACK到达对端需要一个MSL，对端重发的FIN到达需要一个MSL，当2个MSL之后仍未收到重传的FIN，则认为对端已经收到了ACK。

+ 防止上一次连接中的数据延迟到达后影响新连接。TCP连接由五元组(协议，源IP，源端口，目的IP，目的端口, 因协议固定是TCP，也可以说是四元组)唯一标识。假设没有TIME_WAIT状态，一个连接关闭后，可能使用相同的五元组的新连接被建立，这时若原连接上的TCP分段因为网络延时刚刚到达，且它的序列号刚好在新连接的接收窗口，则会令新连接接收的数据混乱。尽管每次建立连接使用的序列号都是随机产生的，但是序列号的长度只有32位，在高速网络上可能很快出现序列号循环。TIME_WAIT状态持续2MSL后，原连接的数据包都已经在网络上消失，不会再干扰新连接。

### 7、TCP是如何实现可靠传输的

TCP实现可靠传输，首先是传输前先建立连接，保证通信双方的数据收发能力都是好的。然后利用校验和、超时重传机制、滑动窗口机制、拥塞控制机制等方法保证数据传输的可靠。

+ 校验和
  发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。

+ 序列号 + 确认应答
  TCP给发送的每一个包进行编号，接收方接收到数据包后会回复对应的ACK应答，这样就能知道哪些数据包没有收到。

+ 超时重传
  当TCP发出一个数据包后，它启动一个定时器（RTO，基于RTTD计算），等待目的端确认收到这个数据包，如果不能及时收到一个确认，将重发这个报文段。

+ 流量控制
  TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。接收方有即时窗口（滑动窗口），随ACK报文发送。

+ 拥塞控制
  通过动态调整拥塞窗口大小，当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小。利用慢启动、拥塞避免、快速重传、快速恢复等控制拥塞。

### 8、什么是TCP粘包，如何避免

因为TCP采取的是字节流的传输方式，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包，多个包首尾相接，无法区分。

导致TCP粘包的原因有三方面：

+ 发送端等待缓冲区满才进行发送，造成粘包；

+ 接收方来不及接收缓冲区内的数据，造成粘包；

+ 由于TCP协议在发送较小的数据包的时候，会启用优化算法（Nagle）将几个包合成一个包后发送。

避免粘包的措施：

+ 通过编程，强制使TCP发送数据，不必等到缓冲区满；

+ 优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等；

+ 设置固定长度的报文或者设置报文头部指示报文的长度；

+ 设置明显的数据包分割符号。

### 9、TCP的封包和拆包

因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘。

+ 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。

+ 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。

### 10、OSI七层模型协议、五层协议

OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。

五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。

+ 应用层：为用户程序提供接口，协议有HTTP、FTP、TFTP、SMTP、DNS、TELNET、HTTPS、POP3、DHCP等；
+ 表示层：数据的表示、安全和压缩，格式有JPEG、ASCII、DECOIC、加密格式等；
+ 会话层：建立、管理和终止会话，对应主机进程，指的是本地主机与远程主机正在进行的会话；
+ 传输层：定义传输数据的协议端口号，以及流量控制和差错校验，协议有TCP、UDP。
+ 网络层：进行逻辑地址寻址（IP寻址），实现不同网络之间的路径选择，协议有ICMP、IGMP、IP、ARP、RARP等；
+ 数据链路层：建立逻辑连接、进行硬件地址寻址（MAC寻址）、差错校验等功能，将比特组合成字节进而组合成帧，用MAC地址访问介质。
+ 物理层：建立、维护和断开物理连接，例如交换机、双绞线等。

### 11、socket关闭close和shutdown的区别

使用close()时，只会将套接字的引用计数减1，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接。

### 12、UDP是如何实现可靠传输的

因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现SEQ和ACK机制，重传机制和窗口确认机制。

发送方给每个UDP包设置递增序列，接收方收到UDP包之后需要回复对应的确认包，当发送方收不到确认包就要重新发送，接收方发现中间丢了包就要发重传请求；当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，设置发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。  

### 13、TCP和UDP的区别

+ TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。

+ TCP提供流量控制和拥塞控制，而UDP没有。

+ TCP对系统资源的要求高于UDP，所以速度也比UDP慢。

+ TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。

+ 所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。

注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。

### 14、TCP和UDP相关的协议

TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。

## 15、TCP（UDP，IP）等首部的认识（HTTP请求报文构成）

TCP的头部大致包括：源端口，目的端口，序号，确认号，标志位，校验和等等；

![tcp-header](https://assets.wangjiaqingll.com/blog-wiki/tcp-header.png?e=1664884328&token=yY18s1LBPDyXOL0gKRG1cTB624r_2fOp-O4he3HN:jwvht39uiwlTWmHBv51tg9FxwGM=)

UDP的头部则包括：源端口，目的端口，长度，校验和；

![UDP-header](https://assets.wangjiaqingll.com/blog-wiki/udp-header.png?e=1664884363&token=yY18s1LBPDyXOL0gKRG1cTB624r_2fOp-O4he3HN:Kr94fknmf4eRlkdMjcOk7k-GHzw=)

IP数据包的头部包括：版本号、首部长度、16位标识，3位标志、13位偏移、源IP地址，目的IP地址，协议，校验和，总长度等等。

![IP-header](https://assets.wangjiaqingll.com/blog-wiki/ip-header.png?e=1664884385&token=yY18s1LBPDyXOL0gKRG1cTB624r_2fOp-O4he3HN:tF57TYfUykscYiwCg62-LmX9h4M=)

### 16、在浏览器中输入URL后执行的全部过程

+ 首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；

+ 然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；

+ 接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）

+ 服务器对客户端发来的http请求进行处理，并返回响应；

+ 客户端接收到http响应，将结果渲染展示给用户。

更加详细：[URL 从输入到页面渲染全流程](https://cloud.tencent.com/developer/article/1679942#:~:text=从输入URL到页面加载的主干流程如下： 1、浏览器构建HTTP,Request请求 2、网络传输)

### 17、网络层分片的主要原因与具体实现

因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。

IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息，接受方就可以利用这些信息对IP数据进行重新组织。

### 18、HTTP协议与TCP的区别与联系

联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。

区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。
建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。

### 19、HTTP1.0、HTTP1.1以及HTTP2.0的区别

**HTTP1.0 VS HTTP1.1**

+ 缓存处理，HTTP1.0中主要使用Header里的IF-Modified-Since，Expires来做为缓存，HTTP1.1则引入了更多缓存控制策略，例如Entity、IF-Unmodified-Since、If-Match等。

+ 带宽优化与网络连接的使用，在HTTP1.0中，存在带宽浪费现象，比如客户端只需要对象的一部分，服务器却将整个对象发送过来，而且不支持断点续传功能；而HTTP1.1则引入了range头域，它允许只请求资源的某一部分，这样可以更充分的利用网络带宽。

+ 错误通知管理，HTTP1.1中新增了24个错误状态响应码，错误响应更具体。

+ Host头，在HTTP1.0中认为每台服务器绑定一个唯一的IP地址，因此请求时URL 不需要包含主机名（Host Name），但是随着虚拟主机技术的发展，一台物理主机上可以存在多个虚拟主机，它们共享一个IP地址，如果不加Host头便不知道客户端具体向哪个服务器进行请求，HTTP1.1中加入了Host头域信息，用于解决这个问题。

+ 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

**HTTP1.x VS HTTP2.0**

+ 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

+ 多路复用（MultiPlexing），即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里。

+ header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

+ 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。

### 20、HTTP的请求方法有哪些？get和post的区别

HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）

**GET和POST的区别：**

+ get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源；

+ get可以保存为书签，可以用缓存来优化，而post不可以；

+ get把请求参数附在url上，而post把参数附在http包的包体中；

+ 浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等；

+ post可以传输二进制编码的信息，get的参数一般只支持ASCII。

### 21、HTTP和HTTPS的区别，由http升级为https需要做哪些操作

+ http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议；
+ http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443；
+ http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全；
+ https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用；

### 22、HTTPS的具体实现，怎么确保安全性

**SSL是传输层的协议**

HTTPS包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。

+ 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接；

+ Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存；

+ 客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站；

+ Web服务器利用自己的私钥解密出会话密钥；

+ Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。

服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书；

客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）。

### 23、TCP三次握手时的第一次的seq序号是怎样产生的

第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。

seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。	

### 24、一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？

65536。因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。

而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。

### 25、数字证书

权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。
网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。

### 26、服务器出现大量close_wait的连接的原因以及解决方法

close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：

+ 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法

+ 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收

处理方法：

+ 停止应用程序

+ 修改程序里的bug

### 27、介绍一下ping的过程，分别用到了哪些协议

ping是使用ICMP协议来进行工作的， ICMP：网络控制报文协议。

+ 首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。

+ 然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。

+ 然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。

+ 目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。

### 28、一个ip配置多个域名，靠什么识别

- 靠host主机名区分
- 靠端口号区分

### 29、DNS的工作过程和原理

![dns-progress](https://assets.wangjiaqingll.com/blog-wiki/dns-progress.png?e=1664880594&token=yY18s1LBPDyXOL0gKRG1cTB624r_2fOp-O4he3HN:iudteghXIg12T08a8ZTl8UQf6fQ=)

DNS解析有两种方式：递归查询和迭代查询

- 递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。
- 迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果。

### 30、IP寻址和MAC寻址有什么不同，怎么实现的

通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，MAC寻址是数据链路层。

IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包。

### 31、GET与POST的区别

+ GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；

+ GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；

+ 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；

+ 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；

+ GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；

+ GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制。

### 32、Session和Cookie的区别

- cookie数据存放在客户的浏览器上，session数据放在服务器上；
- cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session；
- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE；
- 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K；
- 保存session的方式一般可以采用Cookie，如果禁用Cookie可以采用URL重写机制实现Session，即把Session会话ID保存在URL中。
- 将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中；

### 33、HTTP请求常见的状态码有哪些

- 100 Continue，继续，客户端应继续其请求；
- 101 切换协议，服务器根据客户端的请求切换协议，只能切换到更高；
- 2xx状态码：操作成功。200 OK

- 3xx状态码：重定向。301 永久重定向；302暂时重定向
- 4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；
- 5xx状态码：服务端错误。500服务器内部错误；501服务不可用

更多：[HTTP 状态码](https://www.runoob.com/http/http-status-codes.html)

### 34、什么是RIP(Routing Information Protocol，距离矢量路由协议)？算法是什么?

每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。

RIP是应用层协议。

### 35、路由器和交换机位于哪一层？

- 路由器位于网络层，根据IP地址进行寻址；
- 交换机位于数据链路层，根据MAC地址进行寻址。

### 36、什么是ARP协议（Addres Resolution Protocol）

ARP协议，全称是Address Resolution Protocol，又叫地址解析协议，作用是通过IP地址获得对应主机的物理地址，也即MAC地址。

每一个主机都设有一个 ARP 高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向所在的局域网发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做。

ARP缓存有好有坏，可以加速ARP的解析速度，减少局域网的广播风暴；但是可能会出现ARP欺骗攻击的风险。

### 37、什么是NAT(Network Address Translation，网络地址转换)

用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。

### 38、什么是对称加密和非对称加密？区别是什么

- 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4；
- 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA；
- 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）。

### 39、HTTP是否可以使用UDP

HTTP不可以使用UDP传输，HTTP需要基于可靠的传输协议，UDP是不可靠的。

### 40、什么是文件描述符

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

内核通过文件描述符来访问文件。文件描述符指向一个文件。

### 41、什么是IO多路复用，有几种方法

IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。

用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。

### 42、select、poll、epoll三者的区别

- select：在用户态利用线性表维护一个文件描述符集合，调用select时需要将该集合从用户态拷贝到内核态，在内核态上遍历该文件描述符集合，查找是否有继续事件。返回的是有无就绪事件，有的话用户态还需要遍历这个集合找到对应的就绪文件描述符。select有最大文件描述符的限制，32位机器默认是1024，64位是2048，拷贝文件描述符以及轮询方式遍历文件描述符集合开销大，效率低，同时select只能工作在相对低效的LT，也即是水平触发模式。
- poll：poll和select几乎是一样的，区别在于poll在采用的是链表形式维护一个文件描述符集合，并且突破了最大文件描述符限制。
- epoll：epoll直接在内核态维护了一个文件描述符集合，底层是现实红黑树，用户态可以通过一个文件描述符找到该集合，向文件描述符上添加、删除、更改文件描述符均采用系统调用的方式实现，避免了需要从用户态拷贝文件描述符到内核态的开销。文件描述符有就绪时间发生时，采用回调机制，避免了轮询操作，同时就绪的文件描述符会被添加到一个就绪链表中，调用epoll_wait时返回该链表，用户态不需要再去查找哪些文件描述符是就绪的。epoll可以工作在LT模式和ET模式。

### 43、什么时候使用select/poll，什么时候使用epoll

当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。

### 44、LT模式和ET模式

讨论LT模式和ET模式的区别时，一般都是在epoll下，因为只有epoll同时支持两种模式。

LT模式：LT是epoll的默认操作模式，当epoll_wait函数检测到有事件发生并将通知应用程序，而应用程序不一定必须立即进行处理，这样epoll_wait函数再次检测到此事件的时候还会通知应用程序，直到事件被处理。

ET模式：只要epoll_wait函数检测到事件发生，通知应用程序立即进行处理，后续的epoll_wait函数将不再检测此事件。因此ET模式在很大程度上降低了同一个事件被epoll触发的次数，因此效率比LT模式高。

### 45、ET模式比LT模式更高效的原因

ET在通知用户后，就会把fd从就绪队列里删除。而LT通知用户后fd还在就绪链表中，随着fd的增多，就绪链表越大。下次epoll要通知用户时还需要遍历整个就绪链表。遍历的性能是线性，如果fd的数量非常多，就会带来比较显著的效率下降。 同样数量的fd下，LT模式维护的就绪链表比ET的大。

### 46、怎么解决LT模式下就绪事件一直触发的问题

- 每次要写数据时，将fd绑定EPOLLOUT事件，写完后将fd同EPOLLOUT从epoll中移除。
- 方法一中每次写数据都要操作epoll。如果数据量很少，socket很容易将数据发送出去。可以考虑改成：数据量很少时直接send，数据量很多时在采用方法1。

### 47、ET模式下为什么一定是非阻塞

因为ET模式下是无限循环读，直到出现错误为EAGAIN或者EWOULDBLOCK，这两个错误表示socket为空，不用再读了，然后就停止循环了，如果是非阻塞，循环读在socket为空的时候就会阻塞到那里，主线程的read（）函数一旦阻塞住，当再有其他监听事件过来就没办法读了，给其他事情造成了影响，所以必须要设置为非阻塞。

### 48、ICMP协议

ICMP全程Internet Control Message Protocol，即互联网控制消息协议，是一个网络层的协议，主要用来检测网络通信故障和实现链路追踪，例如在IP通信中如果某个包丢失，具体是什么原因就是靠ICMP来就行通知的，最典型的应用就是PING和traceroute。

PING：通过发送回送请求报文和回送回答报文来检测源主机到目的主机的链路是否有问题，目的地是否可达，以及通信的延迟情况。

traceroute：通过发送探测报文来获取链路地址信息。第一个探测报文TTL为1，到达第一个路由器时，TTL减1为0所以丢掉这个探测包，同时向源主机发回ICMP时间超过报文，这时源主机就获得了第一个路由器的IP地址；接着源主机发送第二个探测报文，TTL增1为2，到达第一个路由器TTL减1为1并转发探测包到第二个路由器，这时TTL减1为0，丢掉这个探测包并向源主机发回ICMP时间超过报文，源主机就获得了第二个路由器的IP地址；以此类推，直到探测报文到达traceroute的目的地，这时源主机就获得了到目的地的每一跳路由的IP地址。
